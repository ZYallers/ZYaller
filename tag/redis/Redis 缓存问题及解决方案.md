[//]:# "2023/4/21 14:10|Redis"

# Redis 缓存问题及解决方案
## 缓存来由
随着互联网系统发展的逐步完善，提高系统的qps，目前的绝大部分系统都增加了缓存机制从而避免请求过多的直接与数据库操作从而造成系统瓶颈，极大的提升了用户体验和系统稳定性。

## 缓存问题
虽然使用缓存给系统带来了一定的质的提升，但同时也带来了一些需要注意的问题。

### 1. 缓存穿透
缓存穿透是指查询一个一定不存在的数据，因为缓存中也无该数据的信息，则会直接去数据库层进行查询，从系统层面来看像是穿透了缓存层直接达到db，从而称为缓存穿透，没有了缓存层的保护，这种查询一定不存在的数据对系统来说可能是一种危险，如果有人恶意用这种一定不存在的数据来频繁请求系统，准确的说是攻击系统，请求都会到达数据库层导致db瘫痪从而引起系统故障。

#### 解决方案

缓存穿透业内的解决方案已经比较成熟，主要常用的有以下几种：
1. **空值缓存**：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。
2. **bloom filter(布隆过滤器)**：类似于哈希表的一种算法，用所有可能的查询条件生成一个bitmap，在进行数据库查询之前会使用这个bitmap进行过滤，如果不在其中则直接过滤，从而减轻数据库层面的压力。
3. 网关层增加校验，进行用户鉴权，黑名单控制，接口流量控制。

### 2. 缓存击穿
缓存击穿是指，缓存中数据失效，在高并发情况下，所有用户的请求全部都打到数据库上，短时间造成数据库压力过大。

大家使用过微博的应该都知道，微博有一个热门话题的功能，用户对于热门话题的搜索量往往在一些时刻会大大的高于其他话题，这种我们成为系统的“热点“，由于系统中对这些热点的数据缓存也存在失效时间，在热点的缓存到达失效时间时，此时可能依然会有大量的请求到达系统，没有了缓存层的保护，这些请求同样的会到达db从而可能引起故障。

#### 解决方案

1. **加锁**：当第一个用户请求到时，如果缓存中没有，其他用户的请求先锁住，第一个用户查询数据库后立即缓存到 Redis，然后释放锁，这时候其他用户就可以直接查询缓存。
2. **二级缓存**：对于热点数据进行二级缓存，并对于不同级别的缓存设定不同的失效时间，则请求不会直接击穿缓存层到达数据库。
3. 接口限流、熔断

### 3. 缓存雪崩

在普通的缓存系统中一般例如redis、memcache等中，我们会给缓存设置一个失效时间，但是如果所有的缓存的失效时间相同，那么在同一时间失效时，所有系统的请求都会发送到数据库层，db可能无法承受如此大的压力导致系统崩溃。与缓存击穿不同，击穿是指一个 key 过期，雪崩是指很多 key 同时过期。

#### 解决方案

1. 交错失效时间：这种方法时间比较简单粗暴，既然在同一时间失效会造成请求过多雪崩，那我们错开不同的失效时间即可从一定长度上避免这种问题，在缓存进行失效时间设置的时候，从某个适当的值域中随机一个时间作为失效时间即可。
2. **线程互斥**：只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps。

### 4. 缓存污染

缓存污染是指，由于历史原因，缓存中有很多 key 没有设置过期时间，导致很多 key 其实已经没有用了，但是一直存放在 redis 中，时间久了，redis 内存就被占满了。

#### 解决方案

1. 缓存尽量设置过期时间
2. 设置缓存淘汰策略为最近最少使用的原则，然后将这些数据删除

## 参考文章
- [双11万亿流量下的分布式缓存](https://yq.aliyun.com/articles/290865)
- [缓存淘汰算法](http://flychao88.iteye.com/blog/1977653)

