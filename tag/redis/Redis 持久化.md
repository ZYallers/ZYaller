[//]:# "2023/4/19 15:47|Redis"

# Redis 持久化

> 文章转载自：[cnblog](https://www.cnblogs.com/wugongzi/p/16827473.html)

## 1. 为什么需求持久化

我们知道 Redis 是内存数据库，主打高性能，速度快。相比 Redis 而言，MySQL 的数据则是保存再硬盘中（其实也有内存版的 MySQL 数据库，但是价格极其昂贵，一般公司不会使用），速度慢，但是稳定性好。你想想 Redis 数据保存在内存中，一旦服务器宕机了，数据岂不是全部都没了，这将会出现很大问题。所以 Redis 为了弥补这一缺陷，提供数据持久化机制，即使服务器宕机，依然可以保证数据不丢失。

## 2. 持久化简介

Redis 提供了两种持久化机制 RDB 和 AOF，适用于不同场景

- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储
- AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大

## 3. RDB

RDB 持久化是通过在指定时间间隔对数据进行快照，比如在 8 点钟对数据进行持久化，那么 Redis 会 fork 一个子进程将 8 点那一刻内存中的数据持久化到磁盘上。触发 RDB 持久化有以下几种方法

### 3.1 RDB 持久化方式

#### 3.1.1 执行 save 命令

执行 save 命令进行持久会阻塞 Redis，备份期间 Redis 无法对外提供服务，**一般不建议使用**，使用场景为 Redis 服务器需要停机维护的情况下。

#### 3.1.2 执行 bgsave 命令

bgsave 命令不会阻塞 Redis 主进程，持久化期间 Redis 依然可以正常对外提供服务

#### 3.1.3 通过配置文件中配置的 save 规则来触发

```bash
# save ""        # 该配置表示关闭 RDB 持久化
save 900 1       # 900s 内有 1 个 key 发生变化，则触发 RDB 快照
save 300 10      # 300s 内有 10 个 key 发生变化，则触发 RDB 快照
save 60  10000   # 60s 内有 10000 个 key 发生变化（新增、修改、删除），则触发 RDB 快照
```

### 3.2 RDB 持久化原理

Redis 进行 RDB 时，会 fork 一个子进程来进行数据持久化，这样不妨碍 Redis 继续对外提供服务，提高效率。

曾经面试官出过这样面试题：

假如 Redis 在 8 点触发了 RDB 持久化，持久化用时 2 分钟，在持久化期间，Redis 中有 100 个 key 被修改了，那么 RDB 文件中的 key 是 8 点那一刻的数据，还是变化的呢？

先不要看答案，自己思考 1 分钟，一个问题只有你自己思考了，才能印象深刻。

好，下面我们一起来看下这张图：

![IMG](https://img2022.cnblogs.com/blog/1058428/202210/1058428-20221026103622028-1082924086.png)

从图中我们可以清晰的看到，Redis 备份时，fork 了一个子进程，子进程去做持久化的工作，子进程中的 key 指向了 8 点那一刻的数据，后面 k1 的值修改了，redis 会在内存中创建一个新的值，然后主进程 k1 指针指向新的值，子进程 k1 指针依然指向 19，这样 Redis 持久化的就是 8 点那一刻的数据，不会发生变化。同时，从图中我们也可以看到，Redis 持久化时并不是将内存中数据全部拷贝一份进行备份。

### 3.3 RDB 优缺点

#### 3.3.1 优点

- RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也**可以根据需求恢复到不同版本的数据集**
- RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以**最大化redis的性能**
- 与AOF相比，在恢复大的数据集的时候，RDB方式会**更快一些**

#### 3.3.2 缺点

- 如果备份**间隔时间较长**，RDB 会**丢失较多的数据**。比如 8 点备份一次，8 点半服务器宕机，那么这半小时内的数据就会丢失了

## 4. AOF

AOF 持久化是通过日志的方式，记录每次 Redis 的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以Redis 协议追加保存每次写的操作到文件末尾。Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大。

### 4.1 AOF 持久化配置

```bash
# 是否开启 aof no：关闭；yes: 开启
appendonly no

# aof 文件名
appendfilename "appendonly.aof"

# aof 同步策略
# appendfsync always  # 每个命令都写入磁盘，性能较差
appendfsync everysec  # 每秒写一次磁盘，Redis 默认配置
# appendfsync no      # 由操作系统执行，默认Linux配置最多丢失30秒

# aof 重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发策略
auto-aof-rewrite-percentage 100 # 触发重写百分比 （指定百分比为0，将禁用aof自动重写功能）
auto-aof-rewrite-min-size 64mb  # 触发自动重写的最低文件体积（小于64mb不自动重写）

# 加载aof时如果有错如何处理
# 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 no ，发现错误就会停止，必须修复后才能重新加载。
aof-load-truncated yes

# aof 中是否使用 rdb
# 开启该选项，触发AOF重写将不再是根据当前内容生成写命令。而是先生成RDB文件写到开头，再将RDB生成期间的发生的增量写命令附加到文件末尾。
aof-use-rdb-preamble yes
```

### 4.2 AOF 文件写入

aof 文件是命令追加的方式，先将命令写入缓冲区，时间到了再写如磁盘中

```bash
appendfsync always    # 每个命令都写入磁盘，性能较差
appendfsync everysec  # 每秒写一次磁盘，Redis 默认配置
appendfsync no        # 由操作系统执行，默认Linux配置最多丢失30秒
```

上面配置就是何时写入磁盘中

### 4.3 AOF 重写

aof 文件虽然丢失的数据少，但是随着时间的增加，aof 文件体积越来越大，占用磁盘空间越来越大，恢复时间长。所以 redis 会对 aof 文件进行重写，以减少 aof 文件体积。

下面以一个例子说明

```bash
-- 重写前的 aof
set k1 20
set k2 40
set k1 35
set k3 34
set k2 19

-- 这里 k1 最终的值为 35，k2 最终值为 19，所以不需要写入两个命令
-- 重写后
set k1 35
set k3 34
set k2 19
```

### 4.4 **混合持久化**

从 Redis 4.0 版本开始，引入了混合持久化机制，纯AOF方式、RDB+AOF方式，这一策略由配置参数 `aof-use-rdb-preamble`（使用RDB作为AOF文件的前半段）控制，默认关闭(no)，设置为yes可开启

- no：按照AOF格式写入命令，与4.0前版本无差别；
- yes：先按照RDB格式写入数据状态，然后把重写期间AOF缓冲区的内容以AOF格式写入，文件前半部分为RDB格式，后半部分为AOF格式。

混合持久化优点：

- 大大减少了 aof 文件体积
- 加快了 aof 文件恢复速度，前面是 rdb ，恢复速度快

### 4.5 **AOF 数据恢复**

第一种：纯 AOF

> 恢复时，取出 AOF 中命令，一条条执行恢复

第二种：RDB+AOF

> 先执行 RDB 加载流程，执行完毕后，再取出余下命令，开始一条条执行

### 4.6 AOF 优缺点

#### 4.6.1 优点

- AOF 实时性更好，**丢失数据更少**
- AOF 已经支持混合持久化，文件大小可以有效控制，并提高了**数据加载时的效率**

#### 4.6.2 缺点

- 对于相同的数据集合，**AOF 文件通常会比 RDB 文件大**
- 在特定的 fsync 策略下，**AOF 会比 RDB 略慢**
- AOF **恢复速度**比 RDB 慢
